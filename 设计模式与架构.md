### UML

#### 1. 简介

UML（Unified Modeling Language），即统一建模语言，适用于描述以用例为驱动，以体系结构为中心的软件设计的全过程。为面向对象软件设计提供统一的、标准的、可视化的建模语言。系统的建模有时候很难通过文字来表达（比如说一些复杂的过程等等），用图来说明是最好的办法。

UML的构造块包含3种： 

* 事物（4种）：结构事物，行为事物，分组事物，注释事物
* 关系（4种）：泛化关系，实现关系，依赖关系，关联关系（特例：聚合关系、组合关系） **（强度排序：组合>聚合>关联>依赖）**
* 图（10种）：用例图，类图，对象图，包图，组件图，部署图，状态图，活动图，序列图，协作图 **（常用：用例图，类图，对象图）**

注意：事物是对模型中最具代表性的成分的抽象；关系把事物结合在一起；图聚集了相关的事物。

#### 2. UML事物（4种）

UML包含4种事物：

* 构件事物：UML模型的静态部分，描述概念或物理元素。它包括以下几种：

    * 类：具有相同属性相同操作 相同关系相同语义的对象的描述
    * 接口：描述元素的外部可见行为，即服务集合的定义说明
    * 协作：描述了一组事物间的相互作用的集合
    * 用例：代表一个系统或系统的一部分行为，是一组动作序列的集合
    * 构件：系统中物理存在，可替换的部件
    * 节点：运行时存在的物理元素
    * 另外，参与者、信号应用、文档库、页表等都是上述基本事物的变体

* 行为事物：UML模型图的动态部分，描述跨越空间和时间的行为。它包括以下几种：

    * 交互：实现某功能的一组构件事物之间的消息的集合，涉及消息、动作序列、链接
    * 状态机：描述事物或交互在生命周期内响应事件所经历的状态序列

* 分组事物：UML模型图的组织部分，描述事物的组织结构

    * 包：把元素组织成组的机制

* 注释事物：UML模型的解释部分，用来对模型中的元素进行说明，解释

    * 注解：对元素进行约束或解释的简单符号


#### 3. UML关系

##### 3.1 泛化(generalization)关系

* 说白了就是继承关系。是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。
* 继承是类与类或者接口与接口之间最常见的关系。
* 在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性。

![泛化关系](https://upload-images.jianshu.io/upload_images/2570030-cbac20a04b08b96d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 3.2 实现(realization)关系

* 说白了就是接口关系。指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；
* 在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性；

![实现关系](https://upload-images.jianshu.io/upload_images/2570030-d3bdd4918f389efd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 3.3 依赖(dependency)关系

* 依赖关系也是类与类之间的连接。表示一个类依赖于另一个类的定义。
* 依赖关系总是单向的。
* 可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；
* 表现在代码层面，为类B作为参数被类A在某个method方法中使用。在java中，依赖关系体现为: 局部变量, 方法中的参数, 和对静态方法的调用。

![依赖关系](https://upload-images.jianshu.io/upload_images/2570030-4b30d8e662edff80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 3.4 关联(association)关系

* 关联关系: 表示类与类之间的联接, 它使一个类知道另一个类的属性和方法。
* 关联可以使用单箭头表示单向关联, 使用双箭头或不使用箭头表示双向关联, 不建议使用双向关联。
* 关联有两个端点, 在每个端点可以有一个基数, 表示这个关联的类可以有几个实例。
* 关联关系体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。
* 表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量；在java语言中关联关系是使用实例变量实现的。

常见的基数及含义: 

* 0..1:0 或1 个实例
* 0..*: 对实例的数目没有限制
* 1: 只能有一个实例
* 1..*: 至少有一个实例

![关联关系](https://upload-images.jianshu.io/upload_images/2570030-b67de2caeb808704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 3.4.1 聚合(aggregation)关系

* 聚合关系: 关联关系的一种特例, 是强的关联关系。
* 聚合是整体和个体之间的关系,即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；
* 比如计算机与CPU、公司与员工的关系等；
* 表现在代码层面，和关联关系是一致的，只能从语义级别来区分；聚合关系也是使用实例变量实现的。从java语法上是分不出关联和聚合的。
* 关联关系中两个类是处于相同的层次, 而聚合关系中两不类是处于不平等的层次, 一个表示整体, 一个表示部分。

![聚合关系](https://upload-images.jianshu.io/upload_images/2570030-2ee00b6f8d0c2801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 3.4.2 组合(合成)关系(composition)

* 组合关系：也是关联关系的一种特例，关联关系的一种特例, 是强的关联关系。
* 他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。
* 他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；
* 组合关系不能共享。
* 表现在代码层面，和关联关系是一致的，只能从语义级别来区分。

![组合关系](https://upload-images.jianshu.io/upload_images/2570030-1a988930841dc1e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 4 用例图（Use Case Diagram ）

* 用例图是从用户角度描述系统功能，是用户所能观察到的系统功能的模型图，用例是系统中的一个功能单元。
* 例如下图就描述了用户的购物功能的模型：

![用例图](https://upload-images.jianshu.io/upload_images/2570030-076a7a2a3822d8c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 5. 类图（Class Diagram）

* 类图描述系统中类的静态结构。不仅定义系统中的类，表示类之间的联系如关联、依赖、聚合等，也包括类的内部结构(类的属性和操作)。
* 例如下面的单例模式的类图：

![单例模式](https://upload-images.jianshu.io/upload_images/2570030-11d9226e0a0e5d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

需要注意：

* 每一行分别表示：类型、成员属性、函数（操作）
* 类名斜体表示为抽象
* 下划线表示静态
* 访问权限控制：+表示public；#表示protect；-表示private；~表示package

#### 6. 时序图(Sequence Diagram)

* 顺序图显示对象之间的动态合作关系，它强调对象之间消息发送的顺序，同时显示对象之间的交互。 
* 顺序图的一个用途是用来表示用例中的行为顺序。当执行一个用例行为时，顺序图中的每条消息对应了一个类操作或引起状态转换的触发事件。
* 例如下面的是支付宝的支付流程：

![时序图](https://upload-images.jianshu.io/upload_images/2570030-d093d813e4866031.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

需要注意：

* 实线表示同步消息
* 虚线表示异步消息

### 设计模式的分类

![设计模式分类](https://upload-images.jianshu.io/upload_images/2570030-c2380781cc174368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 单例模式

#### 1. 定义

确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

![单例模式](https://upload-images.jianshu.io/upload_images/2570030-11d9226e0a0e5d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 2. 使用场景

确保某个类只有一个实例对象，避免产生多个对象消耗过多的资源；或者逻辑上某个类的对象应该只有一个，出现多个则出现一些错误。例如：

1. 对IO、数据库、网络、图片、SharePreference等的访问
2. 需要定义大量的静态常量和静态方法，例如Utils类
3. 唯一序列号生成的场合
4. 需要一个共享访问点或者共享数据的场合，例如全局的计数器
5. Android中的SystemService就是通过单例的方式注册到系统当中

#### 3. 实现

##### 3.1 懒汉式

```java
/**
 * 懒汉式
 * 特点：Lazy初始化；线程安全，但是由于每次需要同步性能较低，不建议使用
 */
public class Singleton {

    private static Singleton sInstance;

    private Singleton() {

    }

    public static synchronized Singleton getInstance() {
        if (sInstance == null) {
            sInstance = new Singleton();
        }
        return sInstance;
    }

}
```

##### 3.2 双检锁/双重校验锁（DCL，即 double-checked locking）

```java
/**
 * 双检锁/双重校验锁（DCL，即 double-checked locking）
 * 特点：懒汉式的改进版，Lazy初始化；线程安全，且在多线程情况下能保持高性能
 */
public class Singleton {

    private static Singleton sInstance;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if (sInstance == null) {
            synchronized (Singleton.class) {
                if (sInstance == null) {
                    sInstance = new Singleton();
                }
            }
        }
        return sInstance;
    }

}

```

##### 3.3 饿汉式

```java
/**
 * 饿汉式
 * 特点：非Lazy初始化，浪费内存；线程安全，基于ClassLoader机制避免了多线程的同步问题
 */
public class Singleton {

    //方式一：类装载的时候初始化
    private static Singleton sInstance = new Singleton();

    //方式二：类初始化的时候才去初始化
    static {
        sInstance = new Singleton();
    }

    private Singleton() {

    }

    public static synchronized Singleton getInstance() {
        return sInstance;
    }

}
```

##### 3.4 静态内部类

```java
/**
 * 静态内部类
 * 特点：饿汉式只要类装载或者类初始化的时候单例初始化，但是静态内部类的方式确保调用getInstance才Lazy初始化；线程安全；推荐使用
 */
public class Singleton {

    private static class SingletonHolder {
        private static final Singleton sInstance = new Singleton();
    }

    private Singleton() {
        
    }

    public static Singleton getInstance() {
        return SingletonHolder.sInstance;
    }
    
}
```

##### 3.5 枚举

```java
/**
 * 枚举
 * 特点：Lazy初始化；线程安全；这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。
 */
public enum Singleton {

    INSTANCE

}
```

##### 3.6 通过容器来实现

```java
/**
 * 通过容器来实现
 * 特点：通过特定时机（例如程序初始化）将单例注入到容器当中，使用的时候通过key来获取；降低了耦合度，提高易用性
 */
public class Singleton {

    public static class SingletonManager {

        private SingletonManager() {

        }

        private static Map<String, Singleton> sSingletonMap = new HashMap<>();

        public static void register(String key, Singleton value) {
            if (!sSingletonMap.containsKey(key)) {
                sSingletonMap.put(key, value);
            }
        }

        public static void unregister(String key) {
            if (sSingletonMap.containsKey(key)) {
                sSingletonMap.remove(key);
            }
        }


        public static Singleton getSingleton(String key) {
            return sSingletonMap.get(key);
        }

    }

}
```

##### 3.7 Kotlin中通过object关键字实现

```kotlin
/**
 * Kotlin中通过object关键字可以实现最简单的单例，相当于饿汉式
 * 特点：这种单例只有一个实现的对象；不能自定义构造方法；可以实现接口、继续父类
 */
object Singleton {
    public fun test() {
        println("")
    }
}

//调用方式
fun main(args: Array<String>) {
    Singleton.test();
}
```

#### 4. 优点

1. 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的被创建、销毁，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。
2. 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）； 
3. 单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。 
4. 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。

#### 5. 缺点

1. 单例模式没有接口，扩展很困难，若要扩展，除了修改代码没有第二种途径可以实现。单例模式为什么不能增加接口呢？因为接口对单例模式是没有任何的意义，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。 
2. 单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。 
3. 单例模式与单一职责原则有冲突。一个类应该只实现一个的逻辑，而不关心它是否是单例的，决定它是不是要单例是环境决定的，单例模式把“要单例”和业务逻辑融合也在一个类中。
4. 通常来说，单例对象如果持有Context，很容易引发内存泄漏。此时需要注意传递给单例对象的Context是ApplicationContext。

### 工厂方法模式

#### 1. 定义

工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

![工厂方法模式](https://upload-images.jianshu.io/upload_images/2570030-77c481f8d56e9ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 2. 使用场景

* 复杂对象的生成，代替new的方式来屏蔽产品类的创建过程：需要一种产品，而不想知道也不需要知道工厂是如何生产出来的，只需要知道具体对应的工厂就行。
* 产品的替换需要灵活、可扩展性高的场合。
* 测试驱动开发的框架中，往往通过工厂方法把对象虚拟出来（用得比较少）。
* Android中的Bitmap就是通过工厂方法来创建的。

#### 3. 实现

抽象产品类：

```java
public abstract class Product {

}
```

具体产品类：

```java
public class ConcreteProduct1 extends Product {

}

public class ConcreteProduct2 extends Product {

}
```

抽象工厂类：

```java
public abstract class Factory {

    public abstract <T extends Product> T createProduct(Class<T> clz);

}
```

具体工厂类：

```java
public class ConcreteFactory extends Factory {
    @Override
    public <T extends Product> T createProduct(Class<T> clz) {
        Product product = null;
        try {
            product = (Product) Class.forName(clz.getName()).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return (T) product;
    }
}
```

场景类：

```java
public class Client {

    public static void main(String[] args) {
        ConcreteFactory factory = new ConcreteFactory();
        factory.createProduct(ConcreteProduct1.class);
    }

}
```

#### 4. 优点

* 良好的封装性与解偶。利用工厂的工厂方法类去创建具体的产品对象，隐藏了具体产品对象的创建细节，只需要关心具体产品对应的具体工厂。高层模块只需要关心抽象产品类。
* 遵守开闭原则，扩展性好。加入新的产品类时，只需要同时加入工厂类就可以实现扩展，无需修改原来的代码。

#### 5. 缺点

* 随着产品种类的数量的增长，工厂类也会随之增加，将不利于系统的维护，增加系统编译和运行的开销。


### 抽象工厂模式

#### 1. 定义

为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。

抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时（产品族——两个互相影响的产品线），通过抽象工厂模式产生需要的对象是一种非常好的解决方式。

UML

#### 2. 使用场景

一个对象族(或是一组没有任何关系的对象)都有相同的约束，例如生成不同操作系统的程序，则可以使用抽象工厂模式。（相对来说用得比较少）

#### 3. 实现

两个产品线（1、2和A、B）产品的抽象类及其实现：

```java
public abstract class ProductA {}
public class ConcreteProductA1 extends ProductA {}
public class ConcreteProductA2 extends ProductA {}

public abstract class ProductB {}
public class ConcreteProductB1 extends ProductB {}
public class ConcreteProductB2 extends ProductB {}
```

抽象工厂类：

```java
public abstract class AbstractFactory {

    public abstract ProductA createProductA();

    public abstract ProductB createProductB();
}
```

具体的工厂实现类：

```java
public class Factory1 extends AbstractFactory {

    @Override
    public ProductA createProductA() {
        return new ConcreteProductA1();
    }

    @Override
    public ProductB createProductB() {
        return new ConcreteProductB1();
    }
}


public class Factory2 extends AbstractFactory {

    @Override
    public ProductA createProductA() {
        return new ConcreteProductA2() {
        };
    }

    @Override
    public ProductB createProductB() {
        return new ConcreteProductB2();
    }
}
```

#### 4. 优点

* 封装性：与工厂方法模式一样，高层模块无需关心产品的具体实现，只需要关心接口。
* 产品族内的约束为非公开状态，例如可以控制产品族之间的比例问题。

#### 5. 缺点

* 扩展性差：产品族难扩展，产品等级易扩展。


### 构建者模式

#### 1. 定义

建造者模式也叫做生成器模式。将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

#### 2. 使用场景

* 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
* 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。
* 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。
* 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。

#### 3. 实现

#### 4. 优点

封装性：使用建造者模式可以使客户端不必知道产品内部组成的细节。
建造者相互独立，容易扩展
便于控制细节风险：由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。

#### 5. 缺点



### 模式

#### 1. 定义

#### 2. 使用场景

#### 3. 实现

#### 4. 优点

#### 5. 缺点